# 推荐系统(Recommendation system )介绍

第一版礼包推荐

一、数据
（1）广告数据（用户成分因素）
（2）行为数据（解决道具捆绑和礼包组合召回排序问题）
（3）存量数据（解决召回阶段游戏生态存量阈值过滤问题和排序问题）
（4）业务条件数据（通过运营后台录入，可以参考神策）
例如：物品是否推送开关、权重系数，指定日期必推等设定条件、新商品列表等
二、模型
（1）物品的关联规则模型
通过行为数据计算给出物品组合（礼包的候选池），后面可能还需要根据策划物品相关的配置文件和已知业务规则过滤掉一些无用组合。

模型选择：FP-growth

策略1：物品获取关联规则

策略2：人为配置礼包购买关联规则和礼包内物品关联规则
（2）推荐模型
1.新用户冷启动
策略1：最热内容
策略2：最新内容
策略3：依据user属性数据和一些简单行为类统计指标通过协同过滤方式推荐相似活跃用户购买过的
2.新物品的冷启动
根据item的属性或者已知策划配置内容，计算相似性放到同类物品组合中，替代同类物品成为新的礼包组合
3.活跃用户推荐
召回阶段：
策略1：行为数据向量化，计算用户最近一段时间的行为倾向和购买倾向
策略2：行为数据向量化，通过协同过滤召回相似用户的行为倾向和购买倾向
策略3：新物品和最热策略
过滤阶段：
游戏生态存量过滤规则和业务运营过滤规则
排序阶段：
精排：用户行为倾向+后期礼包购买点击反馈数据迭代
重排：时间周期性因素和运营活动类
三、返回结果
1.离线模型
尽可能按天更新，单日指定时间更新，后端请求时提供uid，模型返回排序好的礼拜列表，效果是用户每天看到的一样的，每个用户不一样。
2.实时模型
这个计算要求会比较高，且部分模型需要简化，中间结果需要预处理缓存，避免响应时间过长，后端请求时提供uid，模型拉取离线或者近线计算好的用户向量数据进行召回和排序，返回礼包列表，效果是用户不同时间看到的结果可能不一样。


算法1-1：

物品池构建：

Step1过滤出相同时间戳内既有add和remove道具的行为

Step2 先只看每个用户每个session下的add，构成一个add list，根据所有的add list利用FP-growth求的添加物品的频繁项组合

Step3 计算add list种每个物品的两个频度指标，一个是数据中每个用户单日的平均频度，一个是每个用户的add list中包含该物品的用户数，两个指标用于后面的召回排序阶段

Step4 计算add list中每个物品同秒remove物品池指标，构建一个字典保存，一个是remove list的频繁项，将每个用户每日该物品同秒内的remove list合并后作为输入，通过FP-growth计算；一个是每个用户的每日该物品同秒内的remove list作为输入，所有remove list并集中每个物品出现的用户数。计算每个add物品的remove列表是为了后续推荐过程在礼包组合中将add物品替换为对应的remove list丰富礼包。

Step4.2：同一个add list组下的remove list可以引入策划业务配置替换成第二级的素材

召回：

Step5：计算用户最近两个session内物品的add list（callway规则过滤后的），和Step2 中故构建的add list进行相似对比，取差集。

过滤：

Step6：存量过滤

排序：

Step7：计算的相似度*系数1+礼包组内的存量情况系数*系数2


一、广告数据

字段             类型         描述

uid                str           用户id
ad_group          str            广告组
age           str            年龄

sex       str          性别

country    str            国家

二、行为数据

1.关联规则用数据

（1）物品获取数据

原始数据：大于{level}的日活用户key = itemFlow ,isAdd = 1的行为数据，orderby 'logdate','uid','timestamp','session_seq'，arraygroupby ‘logdate','uid','session_id'，处理成如下形式：

{ 'logdate'+'uid'+'session_id' : [item1,item2,..,itemk1], ..., 'logdate'+'uid'+'session_id' : [item1,item2,..,itemkn] }
（2）已有礼包购买数据

原始数据：日活用户礼包购买行为日志

字段             类型         描述

uid                str           用户id
pid                int            礼包id
p_rank           str            礼包档位

p_itemlist      json          礼包下的物品id和数量

timestamp     int            购买时间戳

2.验证反馈数据

原始数据：客户端打点：用户点击算法推荐礼包行为（按钮、面板）、用户支付算法推荐礼包行为（按钮、面板）

格式上和ods底层数据形式一致，orderby 'logdate','uid','timestamp','session_seq'

三、存量数据

（1）用于过滤的整体类统计数据

字段             类型         描述
serverid         int            服id
itemid           int            道具id

num              int           总存量

num_median       int       用户存量中位数  （指标类根据抽象的业务规则过滤条件而定）
timestamp    int           日志的时间戳

（2）单个用户个性化召回和排序 即时存量数据

字段             类型         描述
uid         int                  用户id
itemid           int            道具id

num              int           总存量

四、业务条件数据（过滤阶段）

（1）物品池
字段             类型         描述
item_id         int            物品id
isPush           int            是否参与礼包

（2）礼包参数配置  **

字段             类型         描述

rank               str            礼包档位

distribution    json         类型分布，如种类分布、稀有度分布和每个物品下的个数（这块需要看下如何尽可能无业务化抽象）